# -*- coding: utf-8 -*-
"""Presentation2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16WBuf0VZcNSFVQwHbDrbJTjCAjv7YqFp
"""
# Cirq installation to simulate & run quantum circuits.
!pip install --quiet cirq

import cirq

# Creates 6 qubits, simulates 1s, 0s, or both simultaneously.
myqubits = cirq.LineQubit.range(6)

# Creating/starting a fresh blank canvas in order to create the circuit.
mycircuit = cirq.Circuit ()

# All qubits are given Hadamard Gates to put them in constant superposition.
mycircuit.append(cirq.H(myqubits[0]))
mycircuit.append(cirq.H(myqubits[1]))
mycircuit.append(cirq.H(myqubits[2]))
mycircuit.append(cirq.H(myqubits[3]))
mycircuit.append(cirq.H(myqubits[4]))
mycircuit.append(cirq.H(myqubits[5]))

# Displays the circuit.
print(mycircuit)

# This installs the needed package in order to display our circuit as 3D.
!pip install cirq-web

# Importing the needed libraries.
# Creating the 3D circuit.
import cirq
from cirq_web.circuits import Circuit3D

# Again we're defining our 6 qubits.
myqubits = cirq.LineQubit.range(6)

# Rebuilding circuit with Hadamard gates.
mycircuit = cirq.Circuit ()

# We're using a "for loop" to avoid tedious lines.
# Qubit defined as q.
for q in myqubits:
    mycircuit.append(cirq.H(q))

# Display the interactive 3D circuit.
Circuit3D(mycircuit)

import cirq
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display

# Defining out qubits.
myqubits = cirq.LineQubit.range(6)

# We're using a blank canvas to create a circuit.
mycircuit = cirq.Circuit()

# Applying h-gate + bit-flip noise to each qubit.
# A bit-flip randomly flips our qubits from 0 -> 1 & vice versa.
for q in myqubits:
    mycircuit.append(cirq.H(q))
    mycircuit.append(cirq.bit_flip(p=0.1).on(q))  # Simulates noise

# Adding measurements to qubits.
# Measurements allows us to read qubits and get answers.
mycircuit.append(cirq.measure(*myqubits, key='m'))

# Displays the circuit.
print(mycircuit)

# Simulating the noise.
sim = cirq.Simulator()
result = sim.run(mycircuit, repetitions=1000)
print(result)

# Ploting histogram of results.
cirq.plot_state_histogram(result)

# Interactive slider to change parameters.
slider = widgets.FloatSlider(
    value=5.0,  # Initial value
    min=0.0,    # Minimum value
    max=10.0,   # Maximum value
    step=0.1,   # Step size
    description='My Slider:',
    orientation='horizontal',
    readout=True,
    readout_format='.1f',
)
display(slider)

def on_slider_change(change):
    print(f"Slider value changed to: {change.new}")

slider.observe(on_slider_change, names='value')

import cirq
import time

# Measuring aka benchmarking.
# We're using the 6 qubits with H-Gate + noise simulator.
myqubits = cirq.LineQubit.range(6)
mycircuit = cirq.Circuit()

# Applying "for loop" for H-gate & bit-flip.
for q in myqubits:
    mycircuit.append(cirq.H(q))
    mycircuit.append(cirq.bit_flip(p=0.1).on(q))

mycircuit.append(cirq.measure(*myqubits, key='m'))

# Simulation
sim = cirq.Simulator()

start_time = time.time()          # start timer
result = sim.run(mycircuit, repetitions=1000)
end_time = time.time()            # end timer

print("Simulation result:")
print(result)
print(f"Time taken for simulation: {end_time - start_time:.4f} seconds")


# Step-by-step factoring
import cirq
import math
import random
import sympy
import time

# Checking n for prime power.
def find_factor_of_prime_power(n: int) -> int | None:
    """Check if n is a prime power and return the base prime if it is."""
    for k in range(2, math.floor(math.log2(n)) + 1):
        c = n ** (1 / k)
        c1 = math.floor(c)
        if c1**k == n:
            return c1
        c2 = math.ceil(c)
        if c2**k == n:
            return c2
    return None

# Classical order finder
def classical_order_finder(x: int, n: int) -> int | None:
    """Dummy order finder (simulates the quantum step)."""
    for r in range(1, n):
        if pow(x, r, n) == 1:
            return r
    return None

# Factor finding algorithm
def find_factor(n: int, order_finder, max_attempts: int = 30) -> int | None:
    """Try to find a non-trivial factor of n step-by-step."""
    # Step 1: Check
    if sympy.isprime(n):
        print("Step 1: n is prime!")
        return None
    if n % 2 == 0:
        print("Step 1: n is even, factor is 2")
        return 2

    # Step 2: Check for prime power
    c = find_factor_of_prime_power(n)
    if c is not None:
        print(f"Step 2: n is a prime power, factor is {c}")
        return c

    # Step 3: Random x attempts + order finder
    for attempt in range(max_attempts):
        x = random.randint(2, n - 1)
        print(f"Step 3, Attempt {attempt+1}: Random x = {x}")

        # Step 3a: Check GCD
        c = math.gcd(x, n)
        if 1 < c < n:
            print(f"Step 3a: Found factor by GCD = {c}")
            return c

        # Step 3b: Classical order finder
        r = order_finder(x, n)
        if r is None or r % 2 != 0:
            print(f"Step 3b: Order finder failed or r not even, continue")
            continue

        # Step 3c: Compute potential factor
        y = pow(x, r // 2, n)
        c = math.gcd(y - 1, n)
        if 1 < c < n:
            print(f"Step 3c: Found factor via order-finder = {c}")
            return c

    print(f"Step 4: Failed to find a factor after {max_attempts} attempts")
    return None


n = 15  # Small example

start_time = time.time()
p = find_factor(n, order_finder=classical_order_finder)
end_time = time.time()

if p is not None:
    q = n // p
    print(f"\nResult: Factoring n = pq = {n}")
    print(f"p = {p}, q = {q}")
else:
    print(f"\nCould not find a factor for {n}")

print(f"Time taken: {end_time - start_time:.4f} seconds")
