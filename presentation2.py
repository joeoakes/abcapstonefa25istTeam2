# -*- coding: utf-8 -*-
"""Presentation2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16WBuf0VZcNSFVQwHbDrbJTjCAjv7YqFp
"""

!pip install --quiet cirq

import cirq



myqubits = cirq.LineQubit.range(6)  #This is creating 6 qb's. Think of them as 6 tiny spinning pennies :)


mycircuit = cirq.Circuit ()  #creating/starting a fresh blank canvas in order to create the circuit


mycircuit.append(cirq.H(myqubits[0]))  #we're then putting H-gates' on each q-bit. Why? 'Cause H-gates makes the qb's have a constant state of superposition.
mycircuit.append(cirq.H(myqubits[1]))
mycircuit.append(cirq.H(myqubits[2]))
mycircuit.append(cirq.H(myqubits[3]))
mycircuit.append(cirq.H(myqubits[4]))
mycircuit.append(cirq.H(myqubits[5]))

print(mycircuit)

# this just installs the needed package in order to display our circuit as 3d
!pip install cirq-web

# importing the needed libraries
import cirq
from cirq_web.circuits import Circuit3D

# here' again we're defining our 6 qb's
myqubits = cirq.LineQubit.range(6)


mycircuit = cirq.Circuit ()


mycircuit.append(cirq.H(myqubits[0]))
mycircuit.append(cirq.H(myqubits[1]))
mycircuit.append(cirq.H(myqubits[2]))
mycircuit.append(cirq.H(myqubits[3]))
mycircuit.append(cirq.H(myqubits[4]))
mycircuit.append(cirq.H(myqubits[5]))

# Display the interactive 3D circuit
Circuit3D(mycircuit)

import cirq
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display

# defining out qb's
myqubits = cirq.LineQubit.range(6)

# we're using a blank canvas to create a circuit
mycircuit = cirq.Circuit()

# applying h-gate + bit-flip noise to each qubit
#What;s a bit-flip? It flipss our qb from 0 to 1. Think of light switch
#we're using a for loop instead of writing the same two lines 6 times over and over
for q in myqubits:
    mycircuit.append(cirq.H(q))
    mycircuit.append(cirq.bit_flip(p=0.1).on(q))  # Noise

# adding measurement
#why are measurements important? it's how we look at the qb and get answers
mycircuit.append(cirq.measure(*myqubits, key='m'))

# print the circuit
print(mycircuit)

# simulating
sim = cirq.Simulator()
result = sim.run(mycircuit, repetitions=1000)
print(result)
cirq.plot_state_histogram(result)
slider = widgets.FloatSlider(
    value=5.0,  # Initial value
    min=0.0,    # Minimum value
    max=10.0,   # Maximum value
    step=0.1,   # Step size
    description='My Slider:',
    orientation='horizontal',
    readout=True,
    readout_format='.1f',
)
display(slider)

def on_slider_change(change):
    print(f"Slider value changed to: {change.new}")

slider.observe(on_slider_change, names='value')

import cirq
import time

# measuring aka benchmarking.
# we're using the 6 qubits with H-Gate + noise simulator
myqubits = cirq.LineQubit.range(6)
mycircuit = cirq.Circuit()

#again, using loop instead of writing out each qb
for q in myqubits:
    mycircuit.append(cirq.H(q))
    mycircuit.append(cirq.bit_flip(p=0.1).on(q))

mycircuit.append(cirq.measure(*myqubits, key='m'))

# simulate
sim = cirq.Simulator()

start_time = time.time()          # start timer
result = sim.run(mycircuit, repetitions=1000)
end_time = time.time()            # end timer

print("Simulation result:")
print(result)

print(f"Time taken for simulation: {end_time - start_time:.4f} seconds")

# step by step facotring
import cirq
import math
import random
import sympy
import time

#checking prime powers
def find_factor_of_prime_power(n: int) -> int | None:
    """Check if n is a prime power and return the base prime if it is."""
    for k in range(2, math.floor(math.log2(n)) + 1):
        c = n ** (1 / k)
        c1 = math.floor(c)
        if c1**k == n:
            return c1
        c2 = math.ceil(c)
        if c2**k == n:
            return c2
    return None

#classical order finder
def classical_order_finder(x: int, n: int) -> int | None:
    """Dummy order finder (simulates the quantum step)."""
    for r in range(1, n):
        if pow(x, r, n) == 1:
            return r
    return None

#factor finding algorithm
def find_factor(n: int, order_finder, max_attempts: int = 30) -> int | None:
    """Try to find a non-trivial factor of n step-by-step."""
    # step 1:check
    if sympy.isprime(n):
        print("Step 1: n is prime!")
        return None
    if n % 2 == 0:
        print("Step 1: n is even, factor is 2")
        return 2

    # step 2: check for prime power
    c = find_factor_of_prime_power(n)
    if c is not None:
        print(f"Step 2: n is a prime power, factor is {c}")
        return c

    # step 3: random attempts + order finder
    for attempt in range(max_attempts):
        x = random.randint(2, n - 1)
        print(f"Step 3, Attempt {attempt+1}: Random x = {x}")

        # step 3a: check GCD
        c = math.gcd(x, n)
        if 1 < c < n:
            print(f"Step 3a: Found factor by GCD = {c}")
            return c

        # step 3b: classical order finder
        r = order_finder(x, n)
        if r is None or r % 2 != 0:
            print(f"Step 3b: Order finder failed or r not even, continue")
            continue

        # step 3c: compute potential factor
        y = pow(x, r // 2, n)
        c = math.gcd(y - 1, n)
        if 1 < c < n:
            print(f"Step 3c: Found factor via order-finder = {c}")
            return c

    print(f"Step 4: Failed to find a factor after {max_attempts} attempts")
    return None


n = 15  # small num. for examle

start_time = time.time()
p = find_factor(n, order_finder=classical_order_finder)
end_time = time.time()

if p is not None:
    q = n // p
    print(f"\nResult: Factoring n = pq = {n}")
    print(f"p = {p}, q = {q}")
else:
    print(f"\nCould not find a factor for {n}")

print(f"Time taken: {end_time - start_time:.4f} seconds")